<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <style>
    div {
      text-align: center;
    }

    rect {
      stroke: #fff;
    }
  </style>
</head>

<body>
  <div id='chart'></div>
  <script src='d3.min.js'></script>
  <script>
    /*
     * System hierarchy partition chart
     */
    (function(d3, undefined) {

      var CHART_SIZE_RATIO = 0.97; // chart to window width/height ratio
      var COLLAPSED_SIZE_PIXELS = 10; // size in pixels of collapsed partition

      var ww = window.innerWidth;
      var wh = window.innerHeight;
      var cw = ww * CHART_SIZE_RATIO;
      var ch = wh * CHART_SIZE_RATIO;
      var rangeX = d3.scale.linear().range([0, cw]);
      var rangeY = d3.scale.linear().range([0, ch]);
      var focusedDatum = null;
      var svg;
      var rootDatum;

      var color = d3.scale.ordinal()
        .range([
          'rgb(254,232,200)',
          'rgb(253,212,158)',
          'rgb(253,187,132)',
          'rgb(252,141,89)',
          'rgb(239,101,72)',
          'rgb(215,48,31)',
          'rgb(179,0,0)',
          'rgb(127,0,0)'
        ]);

      window.onload = function() {
        // create an svg element and append to the container div
        svg = d3.select('#chart').append('svg:svg')
          .attr('width', cw)
          .attr('height', ch);

        // create a partition layout and set the getChildren and getValue funcs
        var partition = d3.layout.partition()
          .children(getChildren)
          .value(getValue);

        // create svg group elements that correspond to the data nodes
        // and append them to the svg.
        var groups = svg.selectAll('g').data(partition(d3.entries(data)[0]))
          .enter().append('svg:g')
          // set the functions that handle resizing and repositioning partitions
          // for zooming, expading, and collapsing
          .attr('x', deltaX)
          .attr('y', deltaY)
          .attr('width', deltaWidth)
          .attr('height', deltaHeight)
          // give each data node a reference to its corresponding svg group
          .each(function(d) {
            d.element = this;
          });

        // create and append a visible rect for each svg group
        var rects = groups.append('svg:rect')
          .attr('x', deltaX)
          .attr('y', deltaY)
          .attr('width', deltaWidth)
          .attr('height', deltaHeight)
          .attr('fill', fill);

        // create and append a svg text element for each group
        var texts = groups.append('svg:text')
          .attr('font-size', deltaText)
          .text(getText)
          // x and y attrs must be last so they run
          // after the bouding box has been computed
          .attr('x', deltaX)
          .attr('y', deltaY)
          .each(hideOverflowingText);

        // set the rootDatum variable
        groups.each(function(d) {
          if (d.key === 'root') {
            rootDatum = d;
          }
        });

        // set row order of data nodes by their screen x position
        var depth = 1;
        var row = getDataByDepth(depth);
        while (row.length > 0) {
          row.sort(function(a, b) {
              return a.x - b.x;
            })
            .forEach(function(ele, i, arr) {
              ele.rowOrder = i;
            });
          row = getDataByDepth(++depth);
        }

        // set event handlers
        svg.selectAll('g').on('focus', focus);
        svg.selectAll('g').on('click', click);
        svg.selectAll('g').on('contextmenu', click);
      };

      // resize svg on window resize
      window.onresize = function() {
        ww = window.innerWidth;
        wh = window.innerHeight;
        cw = ww * CHART_SIZE_RATIO;
        ch = wh * CHART_SIZE_RATIO;
        rangeX.range([0, cw]);
        rangeY.range([0, ch]);
        transitionAll(1);
      };

      /*
       * extend the d3.selection prototype with some selection methods
       */

      // Adds svg elements of a datum's children to the selection
      d3.selection.prototype.datumChildrenElements = function(datum) {
        var children = datum.element.children;

        if (children != null) {
          for (var i = 0; i < children.length; ++i) {
            this[0].push(children.item(i));
          }
        }

        return this;
      }

      // adds svg elements of a datum's ancestors to the selection
      d3.selection.prototype.datumAncestorElements = function(datum) {
        while (datum.parent != null) {
          this[0].push(datum.parent.element);
          datum = datum.parent;
        }

        return this;
      }

      // adds svg elements of a datum's descendants to the selection
      d3.selection.prototype.datumDescendantElements = function(datum) {
        var children = datum.children;

        if (children != null) {
          for (var i = 0; i < children.length; ++i) {
            _pushd.call(this, children[i]);
          }
        }

        function _pushd(datum) {
          var children = datum.children;

          this[0].push(datum.element);
          this.datumChildrenElements(datum);

          if (children != null) {
            for (var i = 0; i < children.length; ++i) {
              _pushd.call(this, children[i]);
            }
          }
        }

        return this;
      }

      // adds svg elements of a datum's siblings to the selection
      d3.selection.prototype.datumSiblingElements = function(datum) {

        if (datum.parent != null) {
          datum.parent.children.forEach(function(d, i, arr) {
            if (d.element !== datum.element) {
              this[0].push(d.element);
            }
          }, this);
        }

        return this;
      }

      // sets focusedDatum variable to the datum whose svg element has focus
      function focus(d) {
        focusedDatum = d;
      }

      // initiates zooming, collapsing, and expanding
      function click(datum) {
        var button = d3.event.button;

        if (button === 0) {
          if (focusedDatum != null) {
            var d = focusedDatum;
            rangeX.domain([d.x, d.x + d.dx]);
            rangeY.domain([d.y, 1]).range([d.y ? 20 : 0, ch]);
          }
          transitionAll();

        } else if (button > 0) {
          if (this.classList.contains('collapsed')) {
            expand(datum);
          } else {
            collapse(datum);
          }
        }
        d3.event.preventDefault();
      }

      // determines which elements need to be expanded and expands them
      // repositions the rest of the elements as necessary
      function expand(datum) {
        d3.select(datum.element)
          .datumChildrenElements(datum)
          .datumDescendantElements(datum)
          .classed('collapsed', false);

        var parent = datum.parent;
        while (parent != null) {
          d3.select(parent.element).classed('collapsed', false);

          var numExpandedChildren = parent.children.filter(function(d, i, arr) {
            return !d.element.classList.contains('collapsed');
          }).length;

          if (numExpandedChildren === 1) {
            parent.children.forEach(function(d, i, arr) {
              d3.select(d.element).datumDescendantElements(d)
                .classed('collapsed', false);
            });
          }

          parent = parent.parent;
        }

        setExpandingDx();
        setAllRowPositions();
        transitionAll();
      }

      // determines which elements need to be collapsed and collapses them
      // repositions the rest of the elements as necessary
      function collapse(datum) {
        if (datum === rootDatum) {
          return;
        }

        var numNotCollapsed = getDataByDepth(datum.depth).filter(function(d, i, arr) {
          return !d.element.classList.contains('collapsed');
        }).length;

        if (numNotCollapsed === 1) {
          return;
        }

        var collapsing = d3.select(datum.element)
          .datumDescendantElements(datum)
          .classed('collapsed', true);

        var parent = datum.parent;
        while (parent != null) {
          var numExpandedChildren = parent.children.filter(function(d, i, arr) {
            return !d.element.classList.contains('collapsed');
          }).length;

          console.log(parent.key);
          console.log(numExpandedChildren);

          if (numExpandedChildren === 0) {
            d3.select(parent.element).classed('collapsed', true);
            collapsing[0].push(parent.element);
          }

          parent = parent.parent;
        }

        collapsing.each(function(d) {
          if (this.nodeName === 'text') {
            this.style.visibility = 'hidden';
          }

          d.dx = 0;
          var parent = datum;
          while (parent.element.classList.contains('collapsed')) {
            parent.dx = COLLAPSED_SIZE_PIXELS / cw;
            parent = parent.parent;
          }

          d.x = datum.x;
        });

        var parent = datum;
        while (parent.children != null) {
          parent.children.forEach(function(ele, i, arr) {
            ele.dx = (i === 0) ? COLLAPSED_SIZE_PIXELS / cw : 0;
          });
          parent = parent.children[0];
        }

        setExpandingDx();
        setAllRowPositions();
        transitionAll();
      }

      // Set the new size of expanding or resizing elements
      function setExpandingDx() {
        var expanding = d3.selectAll('g').filter(function(d) {
          return !this.classList.contains('collapsed');
        });
        var leaves = getDataLeaves();
        var numExpandedLeaves = 0;
        var numCollapsedAreas = 0;

        leaves.forEach(function(d) {
          if (d.element.classList.contains('collapsed')) {
            if (d.dx !== 0) {
              ++numCollapsedAreas;
            }
          } else {
            ++numExpandedLeaves;
          }
        });

        var unCollapsedArea = cw - numCollapsedAreas * COLLAPSED_SIZE_PIXELS;
        var leafdx = 1 / numExpandedLeaves * unCollapsedArea / cw;

        expanding.each(function(d) {
          if (d.parent == null) {
            return;
          }

          var leaves = getDataLeaves(d);
          var numExpandedLeaves = leaves.filter(function(d, i, arr) {
            return !d.element.classList.contains('collapsed');
          }).length;

          var numCollapsedAreas = 0;

          (function findHighestCollapsedDescendants(d) {
            var children = d.children;
            if (d.children == null) {
              return;
            } else {
              children.forEach(function(child, i, arr) {
                if (child.element.classList.contains('collapsed')) {
                  ++numCollapsedAreas;
                } else {
                  findHighestCollapsedDescendants(child);
                }
              });
            }
          }(d));

          d.dx = leafdx * numExpandedLeaves + numCollapsedAreas * COLLAPSED_SIZE_PIXELS / cw;
        });
      }

      // sets the x position of all elements
      function setAllRowPositions() {
        d3.selectAll('g').each(function(d) {
          if (d.parent == null) {
            return;
          }
          var laterals = getDataByDepth(d.depth);

          d.newX = 0;
          var pos = laterals.indexOf(d);
          for (var i = 0; i < pos; ++i) {
            d.newX += laterals[i].dx;
          }
        }).each(function(d) {
          if (d.parent == null) {
            return;
          }
          d.x = d.newX;
          delete d.newX;
        });
      }

      // triggers a transition to new sizes and positions
      function transitionAll(duration) {
        duration = duration || 500;

        svg.selectAll('g, rect, text').transition()
          .duration(duration)
          .attr('x', deltaX)
          .attr('y', deltaY)
          .attr('width', deltaWidth)
          .attr('height', deltaHeight)
          .filter('text')
          .each('end', hideOverflowingText);
      }

      // calculates a change in x position
      function deltaX(d) {
        var newX = 0;
        var xform = this.getAttribute('transform');

        if (this.nodeName === 'text') {
          var bb = this.getBBox();
          //console.log(bb.width);
          newX = rangeX(d.x) + deltaWidth(d) / 2 - bb.width / 2;

        } else {
          newX = rangeX(d.x);
        }

        return newX;
      }

      // calculates a change in y position
      function deltaY(d) {
        var newY = 0;

        if (this.nodeName === 'text') {
          var bb = this.getBBox();
          newY = rangeY(d.y) + bb.height;

        } else {
          newY = rangeY(d.y);
        }

        return newY;
      }

      // calculates a change in width
      function deltaWidth(d) {
        return rangeX(d.x + d.dx) - rangeX(d.x);
      }

      // calculates a change in height
      function deltaHeight(d) {
        return rangeY(d.y + d.dy) - rangeY(d.y);
      }

      // calculates a change in font size
      function deltaText(d) {
        var wh = window.innerHeight;
        return 32 * wh / (wh + rangeY(d.y));
      }

      // calculates weighted width of a leaf
      // always return 1 so the leaves are all the same size
      function getValue(d) {
        return 1;
      }

      // gets the text of a text elementproperty of a data node
      // returns the key
      function getText(d) {
        return d.key;
      }

      // hides a text element that is larger than the rect it lives on
      function hideOverflowingText(d) {
        var gw = this.parentNode.getAttribute('width');
        var tw = this.getBBox().width;

        if (tw > gw - 10) {
          this.style.visibility = 'hidden';
        } else {
          this.style.visibility = 'visible';
        }
      }

      // colors rects
      function fill(d) {
        return color((d.children ? d : d.parent).key);
      }

      // algorithm that populates the data graph
      // openmdao system variables are not included in the graph
      function getChildren(d) {
        return d3.entries(d.value).filter(function(d, i, arr) {
          return d.value.constructor.name === 'Object';
        });
      }

      // returns all data at a particular depth in row order by screen x position
      function getDataByDepth(depth) {
        var data = [];

        d3.selectAll('g').each(function(d) {
          if (d.depth === depth) {
            data.push(d);
          }
        }).sort(function(a, b) {
          return a.rowOrder - b.rowOrder;
        });

        return data;
      }

      // gets all leaves that are decendants of datum
      function getDataLeaves(datum) {
        var leaves = [];
        var selection;

        if (datum == null) {
          selection = d3.selectAll('g');

        } else {
          selection = d3.select(datum.element);
          selection = selection.datumDescendantElements(datum)
            .filter(function(d) {
              return this.nodeName === 'g';
            });
        }

        selection.each(function(d) {
          if (d.children == null) {
            leaves.push(d);
          }
        });

        return leaves;
      }

      // the text data in JSON format
      var data = {
        'root': {
          'chem_eq': {
            'n2ls': {
              'chem_eq:n2ls:rhs': {
                'relative_name': 'rhs',
                'shape': [3],
                'size': 3,
                'val': [0.0, 0.0, 0.0],
                'desc': 'Right-hand side of resulting system'
              },
              'chem_eq:n2ls:mu': {
                'val': [0.0, 0.0, 0.0],
                'relative_name': 'mu',
                'shape': [3],
                'units': 'cal/(g*mol)',
                'desc': 'Chemical Potential per Kilogram-mole of species j',
                'size': 3
              },
              'chem_eq:n2ls:ch': {
                'relative_name': 'ch',
                'shape': [3, 3],
                'size': 9,
                'val': [
                  [0.0, 0.0, 0.0],
                  [0.0, 0.0, 0.0],
                  [0.0, 0.0, 0.0]
                ],
                'desc': 'Left-hand side of resulting system'
              },
              'chem_eq:n2ls:b': {
                'relative_name': 'b',
                'shape': [2],
                'size': 2,
                'val': [0.0, 0.0],
                'desc': 'assigned kg-atoms of element i per total kg of reactant'
              },
              'chem_eq:n2ls:b0': {
                'relative_name': 'b0',
                'shape': [2],
                'size': 2,
                'val': [0.0, 0.0],
                'desc': 'assigned kg-atoms of element i per total kg of reactant for the initial prod amounts'
              }
            },
            'ls2pi': {
              'chem_eq:ls2pi:x': {
                'shape': [3],
                'relative_name': 'x',
                'state': true,
                'val': [0.0, 0.0, 0.0],
                'size': 3
              }
            },
            'pi2n': {
              'chem_eq:pi2n:dLn': {
                'relative_name': 'dLn',
                'shape': [4],
                'size': 4,
                'val': [0.0, 0.0, 0.0, 0.0],
                'desc': 'Kilogram-moles of species j per kg mixture last element:             Kilogram-moles of mixture per unit mass'
              }
            },
            'next_n': {
              'chem_eq:next_n:lambdaf': {
                'relative_name': 'lambdaf',
                'shape': 1,
                'size': 1,
                'val': 1.0,
                'desc': 'adaptive under-relaxation factor'
              },
              'chem_eq:next_n:n': {
                'val': [0.03333333333333333, 0.03333333333333333, 0.03333333333333333, 0.1],
                'state': true,
                'relative_name': 'n',
                'shape': [4],
                'desc': 'computed value of the next iterate for n',
                'size': 4
              }
            }
          },
          'props': {
            'TP2ls': {
              'props:TP2ls:rhs_T': {
                'relative_name': 'rhs_T',
                'shape': [3],
                'size': 3,
                'val': [0.0, 0.0, 0.0],
                'desc': 'rhs for the T solve'
              },
              'props:TP2ls:rhs_P': {
                'relative_name': 'rhs_P',
                'shape': [3],
                'size': 3,
                'val': [0.0, 0.0, 0.0],
                'desc': 'rhs for the P solve'
              },
              'props:TP2ls:lhs_TP': {
                'relative_name': 'lhs_TP',
                'shape': [3, 3],
                'size': 9,
                'val': [
                  [0.0, 0.0, 0.0],
                  [0.0, 0.0, 0.0],
                  [0.0, 0.0, 0.0]
                ],
                'desc': 'A matrix for the totals linear solve'
              }
            },
            'ls2t': {
              'props:ls2t:x': {
                'shape': [3],
                'relative_name': 'x',
                'state': true,
                'val': [0.0, 0.0, 0.0],
                'size': 3
              }
            },
            'ls2p': {
              'props:ls2p:x': {
                'shape': [3],
                'relative_name': 'x',
                'state': true,
                'val': [0.0, 0.0, 0.0],
                'size': 3
              }
            },
            'tp2tot': {
              'props:tp2tot:h': {
                'val': 0.0,
                'relative_name': 'h',
                'shape': 1,
                'units': 'cal/g',
                'desc': 'enthalpy',
                'size': 1
              },
              'props:tp2tot:S': {
                'val': 0.0,
                'relative_name': 'S',
                'shape': 1,
                'units': 'cal/(g*degK)',
                'desc': 'entropy',
                'size': 1
              },
              'props:tp2tot:gamma': {
                'relative_name': 'gamma',
                'shape': 1,
                'size': 1,
                'val': 0.0,
                'desc': 'ratio of specific heats'
              },
              'props:tp2tot:Cp': {
                'val': 0.0,
                'relative_name': 'Cp',
                'shape': 1,
                'units': 'cal/(g*degK)',
                'desc': 'Specific heat at constant pressure',
                'size': 1
              },
              'props:tp2tot:Cv': {
                'val': 0.0,
                'relative_name': 'Cv',
                'shape': 1,
                'units': 'cal/(g*degK)',
                'desc': 'Specific heat at constant volume',
                'size': 1
              },
              'props:tp2tot:rho': {
                'val': 0.0,
                'relative_name': 'rho',
                'shape': 1,
                'units': 'g/cm**3',
                'desc': 'density',
                'size': 1
              }
            }
          },
          'init_prod': {
            'init_prod:init_prod_amounts': {
              'shape': [3],
              'relative_name': 'init_prod_amounts',
              'val': [0.022722108611679163, 0.0, 0.0],
              'size': 3
            }
          },
          'temp': {
            'temp:T': {
              'units': 'degK',
              'shape': 1,
              'relative_name': 'T',
              'val': 4000.0,
              'size': 1
            }
          },
          'pressure': {
            'pressure:P': {
              'shape': 1,
              'relative_name': 'P',
              'val': 1.03421,
              'size': 1
            }
          },
          'stupid_english_units': {
            'stupid_english_units:T_eng': {
              'units': 'degR',
              'shape': 1,
              'relative_name': 'T_eng',
              'val': 0.0,
              'size': 1
            }
          }
        }
      };
    }(d3));
  </script>
</body>

</html>
