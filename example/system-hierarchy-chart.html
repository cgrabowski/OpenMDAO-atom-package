<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <title>System Hierarchy</title>
  <style>
    * {
      outline: none;
    }

    rect {
      stroke: #fff;
    }

    text {
      cursor: default;
    }

    #chart {
      text-align: center;
    }

    #help,
    .help-icon {
      position: fixed;
      top: 15px;
      right: 15px;
    }

    #help {
      text-align: left;
      background-color: white;
      border: 1px solid black;
      display: none;
      margin: none;
      padding: 15px;
    }

    .help-icon {
      cursor: pointer;
    }

    #close-help-button {
      cursor: pointer;
      font-family: "sans-serif";
      padding-left: 3px;
      padding-right: 2px;
      position: absolute;
      top: 0px;
      right: 0px;
      border-left: 2px solid black;
      border-bottom: 2px solid black;
      margin: none;
    }
  </style>
</head>

<body>
  <div id='chart'></div>
  <svg id='help-icon-background' class='help-icon' height="48" viewBox="0 0 48 48" width='48' xmlns="http://www.w3.org/2000/svg">
    <circle fill='#ffffff' cx='18' cy='18' r='18' />
  </svg>
  <svg id='help-icon-paths' class='help-icon' fill="#000000" height="48" viewBox="0 0 48 48" width="48" xmlns="http://www.w3.org/2000/svg">
    <g transform='scale(1.5, 1.5)'>
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"
      />
    </g>
  </svg>
  <div id='help'>
    <h3>OpenMDAO System Hierarchy Partition Chart</h3>
    <p>
      <strong>left mouse button</strong>: zoom in and out
      <br /> note: click the very top of the screen to zoom out.
    </p>
    <p>
      <strong>center and right mouse buttons</strong>: collapse and expand partitions
    </p>
    <div id='close-help-button'>
      <strong>X</strong>
    </div>
  </div>
  <script src='d3.min.js'></script>
  <script>
    /*
     * System Hierarchy Partition Chart
     */
    (function(d3, undefined) {

      var CHART_SIZE_RATIO = 0.97; // chart to window width/height ratio
      var COLLAPSED_SIZE_PIXELS = 10; // size in pixels of collapsed partition
      var DEFAULT_TRANSITION_DURATION = 500; // transition duration millis

      var ww = window.innerWidth;
      var wh = window.innerHeight;
      var cw = ww * CHART_SIZE_RATIO;
      var ch = wh * CHART_SIZE_RATIO;
      var rangeX = d3.scale.linear().range([0, cw]);
      var rangeY = d3.scale.linear().range([0, ch]);
      // matches only a trailin string of alphanumeric characters
      // (includng the underscore character)
      var removeParentNamesRegex = /\w*$/;
      // matches trailing elipsis
      var elipsisRegex = /\.\.\.$/;
      var focusedDatum = null;
      var svg;
      var rootDatum;

      var color = d3.scale.ordinal()
        .range([
          'rgb(254,232,200)',
          'rgb(253,212,158)',
          'rgb(253,187,132)',
          'rgb(252,141,89)',
          'rgb(239,101,72)',
          'rgb(215,48,31)',
          'rgb(179,0,0)',
          'rgb(127,0,0)'
        ]);

      window.onload = function() {

        // create an svg element and append to the container div
        svg = d3.select('#chart').append('svg:svg')
          .attr('width', cw)
          .attr('height', ch);

        // create a partition layout and set the getChildren and getValue funcs
        var partition = d3.layout.partition()
          .children(getChildren)
          .sort(function(a, b) {
            return a.siblingOrder - b.siblingOrder;
          })
          // calculates weighted width of a leaf
          // always return 1 so the leaves are all the same size
          .value(function(d) {
            return 1;
          });

        // create svg group elements that correspond to the data nodes
        // and append them to the svg.
        var groups = svg.selectAll('g').data(partition(d3.entries(data)[0]))
          .enter().append('svg:g')
          // set the functions that handle resizing and repositioning partitions
          // for zooming, expading, and collapsing
          .attr('x', deltaX)
          .attr('y', deltaY)
          .attr('width', deltaWidth)
          .attr('height', deltaHeight)
          // give each data node a reference to its corresponding svg group
          .each(function(d) {
            d.element = this;
          });

        // create and append a visible rect for each svg group
        var rects = groups.append('svg:rect')
          .attr('x', deltaX)
          .attr('y', deltaY)
          .attr('width', deltaWidth)
          .attr('height', deltaHeight)
          // colors rects
          .attr('fill', function(d) {
            return color((d.children ? d : d.parent).key);
          });

        // create and append tooltip popup elements
        var titles = groups.append('svg:title');

        // create and append a svg text element for each group
        var texts = groups.append('svg:text')
          .attr('font-size', deltaText)
          // gets the text of a text elementproperty of a data node
          // returns the key
          .text(function(d) {
            return removeParentNamesRegex.exec(d.key);
          })
          // x and y attrs must be last so they run
          // after the bouding box has been computed
          .attr('x', deltaX)
          .attr('y', deltaY)
          .each(handleTextAndTooltips);

        // set the rootDatum variable
        groups.filter(function(d) {
          return d.parent == null;
        }).each(function(d) {
          rootDatum = d;
        });

        // set row order of data nodes by their screen x position
        var depth = 1;
        var row = getDataByDepth(depth);
        while (row.length > 0) {
          row.sort(function(a, b) {
              return a.x - b.x;
            })
            .forEach(function(ele, i, arr) {
              ele.rowOrder = i;
            });
          row = getDataByDepth(++depth);
        }

        // set event handlers
        svg.selectAll('g').on('click', click);
        svg.selectAll('g').on('contextmenu', click);
        // sets focusedDatum variable to the datum whose svg element has focus
        svg.selectAll('g').on('focus', function(d) {
          focusedDatum = d;
        });

        var helpIconElements = document.getElementsByClassName('help-icon');
        var helpDiv = document.getElementById('help');
        var closeHelpButton = document.getElementById('close-help-button');

        for (var i = 0; i < helpIconElements.length; ++i) {
          helpIconElements.item(i).onclick = function(event) {
            helpDiv.style.display = 'inline-block';
            for (var i = 0; i < helpIconElements.length; ++i) {
              helpIconElements.item(i).style.display = 'none';
            }
            return false;
          };
        }
        closeHelpButton.onclick = function(event) {
          for (var i = 0; i < helpIconElements.length; ++i) {
            helpIconElements.item(i).style.display = 'block';
          }
          helpDiv.style.display = 'none';
          return false;
        };
      };

      // resize svg on window resize
      window.onresize = function() {
        ww = window.innerWidth;
        wh = window.innerHeight;
        cw = ww * CHART_SIZE_RATIO;
        ch = wh * CHART_SIZE_RATIO;
        rangeX.range([0, cw]);
        rangeY.range([0, ch]);
        transitionAll(100);
      };

      /*
       * extend the d3.selection prototype with some selection methods
       */

      // Adds svg elements of a datum's childrewindow.outerWidthn to the selection
      d3.selection.prototype.datumChildrenElements = function(datum) {
        var children = datum.element.children;

        if (children != null) {
          for (var i = 0; i < children.length; ++i) {
            this[0].push(children.item(i));
          }
        }

        return this;
      }

      // adds svg elements of a datum's ancestors to the selection
      d3.selection.prototype.datumAncestorElements = function(datum) {
        while (datum.parent != null) {
          this[0].push(datum.parent.element);
          datum = datum.parent;
        }

        return this;
      }

      // adds svg elements of a datum's descendants to the selection
      d3.selection.prototype.datumDescendantElements = function(datum) {
        (function _pushd(d) {
          var children = d.children;

          if (children != null) {
            for (var i = 0; i < children.length; ++i) {
              this[0].push(children[i].element);
              _pushd.call(this, children[i]);
            }
          }
        }).call(this, datum);

        return this;
      }

      // adds svg elements of a datum's siblings to the selection
      d3.selection.prototype.datumSiblingElements = function(datum) {
        if (datum.parent != null) {
          datum.parent.children.forEach(function(d, i, arr) {
            if (d.element !== datum.element) {
              this[0].push(d.element);
            }
          }, this);
        }

        function focus(d) {
          focusedDatum = d;
        }
        return this;
      }

      // initiates zooming, collapsing, and expanding
      function click(datum) {
        var button = d3.event.button;

        if (button === 0) {
          if (focusedDatum != null) {
            var d = focusedDatum;
            rangeX.domain([d.x, d.x + d.dx]);
            rangeY.domain([d.y, 1]).range([d.y ? 20 : 0, ch]);
          }
          transitionAll();

        } else if (button > 0) {
          if (this.classList.contains('collapsed')) {
            expand(datum);
          } else {
            collapse(datum);
          }
        }
        d3.event.preventDefault();
      }

      // determines which elements need to be expanded and expands them
      // repositions the rest of the elements as necessary
      function expand(datum) {
        d3.select(datum.element)
          .datumChildrenElements(datum)
          .datumDescendantElements(datum)
          .classed('collapsed', false);

        var parent = datum.parent;
        while (parent != null) {
          d3.select(parent.element).classed('collapsed', false);

          var numExpandedChildren = parent.children.filter(function(d, i, arr) {
            return !d.element.classList.contains('collapsed');
          }).length;

          if (numExpandedChildren === 1) {
            parent.children.forEach(function(d, i, arr) {
              d3.select(d.element).datumDescendantElements(d)
                .classed('collapsed', false);
            });
          }

          parent = parent.parent;
        }

        setExpandingDx();
        setAllRowPositions();
        transitionAll();
      }

      // determines which elements need to be collapsed and collapses them.
      // repositions the rest of the elements as necessary
      function collapse(datum) {
        if (datum === rootDatum) {
          return;
        }

        var numNotCollapsed = getDataByDepth(datum.depth).filter(function(d, i, arr) {
          return !d.element.classList.contains('collapsed');
        }).length;

        if (numNotCollapsed === 1) {
          return;
        }

        var collapsing = d3.select(datum.element)
          .datumDescendantElements(datum)
          .classed('collapsed', true);

        var parent = datum.parent;
        while (parent != null) {
          var numExpandedChildren = parent.children.filter(function(d, i, arr) {
            return !d.element.classList.contains('collapsed');
          }).length;

          if (numExpandedChildren === 0) {
            d3.select(parent.element).classed('collapsed', true);
            collapsing[0].push(parent.element);
            // if parent has no more expanded children, then it becomes the
            // root of the collapse
            datum = parent;
          }

          parent = parent.parent;
        }

        collapsing.each(function(d) {
          if (this.nodeName === 'text') {
            this.style.visibility = 'hidden';
          }

          d.dx = 0;
          var parent = datum;
          while (parent.element.classList.contains('collapsed')) {
            parent.dx = COLLAPSED_SIZE_PIXELS / cw;
            parent = parent.parent;
          }

          d.x = datum.x;
        });

        parent = datum;
        while (parent.children != null) {
          parent.children.forEach(function(d, i, arr) {
            if (i === 0) {
              d.dx = COLLAPSED_SIZE_PIXELS / cw;
            } else {

              d.dx = 0;
              d3.select(d.element).datumDescendantElements(d).each(function(d) {
                d.dx = 0;
              });
            }
          });
          parent = parent.children[0];
        }

        setExpandingDx();
        setAllRowPositions();
        transitionAll();
      }

      // Set the new size of expanding or resizing elements
      function setExpandingDx() {
        var expanding = svg.selectAll('g').filter(function(d) {
          return !this.classList.contains('collapsed');
        });
        var leaves = getDataLeaves();
        var numExpandedLeaves = 0;
        var numCollapsedAreas = 0;

        leaves.forEach(function(d) {
          if (d.element.classList.contains('collapsed')) {
            if (d.dx !== 0) {
              ++numCollapsedAreas;
            }
          } else {
            ++numExpandedLeaves;
          }
        });

        var unCollapsedArea = cw - numCollapsedAreas * COLLAPSED_SIZE_PIXELS;
        var leafdx = 1 / numExpandedLeaves * unCollapsedArea / cw;

        expanding.each(function(d) {
          if (d.parent == null) {
            return;
          }

          var leaves = getDataLeaves(d);
          var numExpandedLeaves = leaves.filter(function(d, i, arr) {
            return !d.element.classList.contains('collapsed');
          }).length;

          var numCollapsedAreas = 0;

          (function findCollapsedDescendantAreas(d) {
            var children = d.children;

            if (d.children == null) {
              return;

            } else {
              children.forEach(function(child, i, arr) {
                if (child.element.classList.contains('collapsed')) {
                  ++numCollapsedAreas;
                } else {
                  findCollapsedDescendantAreas(child);
                }
              });
            }
          }(d));

          d.dx = leafdx * numExpandedLeaves + numCollapsedAreas * COLLAPSED_SIZE_PIXELS / cw;
        });
      }

      // sets the x position of all elements
      function setAllRowPositions() {
        svg.selectAll('g').each(function(d) {
          if (d.parent == null) {
            return;
          }
          var laterals = getDataByDepth(d.depth);

          d.newX = 0;
          var pos = laterals.indexOf(d);
          for (var i = 0; i < pos; ++i) {
            d.newX += laterals[i].dx;
          }
        }).each(function(d) {
          if (d.parent == null) {
            return;
          }
          d.x = d.newX;
          delete d.newX;
        });
      }

      // triggers a transition to new sizes and positions
      function transitionAll(duration) {
        duration = duration || DEFAULT_TRANSITION_DURATION;

        svg.selectAll('g, rect, text').transition()
          .duration(duration)
          .attr('x', deltaX)
          .attr('y', deltaY)
          .attr('width', deltaWidth)
          .attr('height', deltaHeight)
          .filter('text')
          .each('end', handleTextAndTooltips);
      }

      // calculates a change in x position
      function deltaX(d) {
        var newX = 0;

        if (this.nodeName === 'text') {
          var bb = this.getBBox();
          newX = rangeX(d.x) + deltaWidth(d) / 2 - bb.width / 2;

        } else {
          newX = rangeX(d.x);
        }

        return newX;
      }

      // calculates a change in y position
      function deltaY(d) {
        var newY = 0;

        if (this.nodeName === 'text') {
          var bb = this.getBBox();
          newY = rangeY(d.y) + bb.height;

        } else {
          newY = rangeY(d.y);
        }

        return newY;
      }

      // calculates a change in width
      function deltaWidth(d) {
        return rangeX(d.x + d.dx) - rangeX(d.x);
      }

      // calculates a change in height
      function deltaHeight(d) {
        return rangeY(d.y + d.dy) - rangeY(d.y);
      }

      // calculates a change in font size
      function deltaText(d) {
        var wh = window.innerHeight;
        return 32 * wh / (wh + rangeY(d.y));
      }

      // hides a text element that is larger than the rect it lives on
      function handleTextAndTooltips(d) {
        this.innerHTML = removeParentNamesRegex.exec(d.key);

        var gw = this.parentNode.getAttribute('width');
        var tw = this.getBBox().width;
        var siblings = this.parentNode.childNodes;
        var tooltip;
        for (var i = 0; i < siblings.length; ++i) {
          if (siblings.item(i).nodeName === 'title') {
            tooltip = siblings.item(i);
            break;
          }
        }

        if (tw > gw - 10) {
          if (this.parentNode.classList.contains('collapsed')) {
            this.style.visibility = 'hidden';
            tooltip.innerHTML = d.key;
          } else {
            this.style.visibility = 'visible';
            tooltip.innerHTML = '';

            if (elipsisRegex.test(this.innerHTML) === false) {
              this.innerHTML += '...';
            }

            var textLength = this.innerHTML.length - 3;
            while (this.getBBox().width > parseInt(this.parentNode.getAttribute('width')) - 10) {
              if (textLength < 1) {
                this.innerHTML = '...';
                break;
              } else {
                this.innerHTML = this.innerHTML.substr(0, --textLength) + '...';
              }
            }

            if (this.innerHTML.length < 3) {
              this.innerHTML = '';
            }
            var px = parseInt(this.parentNode.getAttribute('x'));
            var pw = parseInt(this.parentNode.getAttribute('width'));
            tw = this.getBBox().width;

            this.setAttribute('x', px + (pw / 2 - tw / 2));
          }
        } else {
          if (this.parentNode.classList.contains('collapsed')) {
            this.style.visibility = 'hidden';
            tooltip.innerHTML = d.key;
          } else {
            this.style.visibility = 'visible';
            tooltip.innerHTML = '';
          }

          if (elipsisRegex.test(this.innerHTML) === true) {
            this.innerHTML = removeParentNamesRegex.exec(d.key);
          }

          var px = parseInt(this.parentNode.getAttribute('x'));
          var pw = parseInt(this.parentNode.getAttribute('width'));
          tw = this.getBBox().width;

          this.setAttribute('x', px + (pw / 2 - tw / 2));
        }
      }

      // algorithm that populates the data graph
      // openmdao system variables are not included in the graph
      function getChildren(d) {
        var vals = d3.entries(d.value);

        vals.forEach(function(ele, i, arr) {
          ele.siblingOrder = i;
        });

        return vals.filter(function(d, i, arr) {
          return d.value.constructor.name === 'Object';
        });
      }

      // returns all data at a particular depth in row order by screen x position
      function getDataByDepth(depth) {
        var data = [];

        svg.selectAll('g').each(function(d) {
          if (d.depth === depth) {
            data.push(d);
          }
        }).sort(function(a, b) {
          return a.rowOrder - b.rowOrder;
        });

        return data;
      }

      // gets all leaves that are decendants of datum
      function getDataLeaves(datum) {
        var leaves = [];
        var selection;

        if (datum == null) {
          selection = svg.selectAll('g');

        } else {
          selection = d3.select(datum.element);
          selection = selection.datumDescendantElements(datum)
            .filter(function(d) {
              return this.nodeName === 'g';
            });
        }

        selection.each(function(d) {
          if (d.children == null) {
            leaves.push(d);
          }
        });

        return leaves;
      }

      // the text data in JSON format
      var data = {
        'root': {
          'chem_eq': {
            'n2ls': {
              'chem_eq:n2ls:rhs': {
                'relative_name': 'rhs',
                'shape': [3],
                'size': 3,
                'val': [0.0, 0.0, 0.0],
                'desc': 'Right-hand side of resulting system'
              },
              'chem_eq:n2ls:mu': {
                'val': [0.0, 0.0, 0.0],
                'relative_name': 'mu',
                'shape': [3],
                'units': 'cal/(g*mol)',
                'desc': 'Chemical Potential per Kilogram-mole of species j',
                'size': 3
              },
              'chem_eq:n2ls:ch': {
                'relative_name': 'ch',
                'shape': [3, 3],
                'size': 9,
                'val': [
                  [0.0, 0.0, 0.0],
                  [0.0, 0.0, 0.0],
                  [0.0, 0.0, 0.0]
                ],
                'desc': 'Left-hand side of resulting system'
              },
              'chem_eq:n2ls:b': {
                'relative_name': 'b',
                'shape': [2],
                'size': 2,
                'val': [0.0, 0.0],
                'desc': 'assigned kg-atoms of element i per total kg of reactant'
              },
              'chem_eq:n2ls:b0': {
                'relative_name': 'b0',
                'shape': [2],
                'size': 2,
                'val': [0.0, 0.0],
                'desc': 'assigned kg-atoms of element i per total kg of reactant for the initial prod amounts'
              }
            },
            'ls2pi': {
              'chem_eq:ls2pi:x': {
                'shape': [3],
                'relative_name': 'x',
                'state': true,
                'val': [0.0, 0.0, 0.0],
                'size': 3
              }
            },
            'pi2n': {
              'chem_eq:pi2n:dLn': {
                'relative_name': 'dLn',
                'shape': [4],
                'size': 4,
                'val': [0.0, 0.0, 0.0, 0.0],
                'desc': 'Kilogram-moles of species j per kg mixture last element:             Kilogram-moles of mixture per unit mass'
              }
            },
            'next_n': {
              'chem_eq:next_n:lambdaf': {
                'relative_name': 'lambdaf',
                'shape': 1,
                'size': 1,
                'val': 1.0,
                'desc': 'adaptive under-relaxation factor'
              },
              'chem_eq:next_n:n': {
                'val': [0.03333333333333333, 0.03333333333333333, 0.03333333333333333, 0.1],
                'state': true,
                'relative_name': 'n',
                'shape': [4],
                'desc': 'computed value of the next iterate for n',
                'size': 4
              }
            }
          },
          'props': {
            'TP2ls': {
              'props:TP2ls:rhs_T': {
                'relative_name': 'rhs_T',
                'shape': [3],
                'size': 3,
                'val': [0.0, 0.0, 0.0],
                'desc': 'rhs for the T solve'
              },
              'props:TP2ls:rhs_P': {
                'relative_name': 'rhs_P',
                'shape': [3],
                'size': 3,
                'val': [0.0, 0.0, 0.0],
                'desc': 'rhs for the P solve'
              },
              'props:TP2ls:lhs_TP': {
                'relative_name': 'lhs_TP',
                'shape': [3, 3],
                'size': 9,
                'val': [
                  [0.0, 0.0, 0.0],
                  [0.0, 0.0, 0.0],
                  [0.0, 0.0, 0.0]
                ],
                'desc': 'A matrix for the totals linear solve'
              }
            },
            'ls2t': {
              'props:ls2t:x': {
                'shape': [3],
                'relative_name': 'x',
                'state': true,
                'val': [0.0, 0.0, 0.0],
                'size': 3
              }
            },
            'ls2p': {
              'props:ls2p:x': {
                'shape': [3],
                'relative_name': 'x',
                'state': true,
                'val': [0.0, 0.0, 0.0],
                'size': 3
              }
            },
            'tp2tot': {
              'props:tp2tot:h': {
                'val': 0.0,
                'relative_name': 'h',
                'shape': 1,
                'units': 'cal/g',
                'desc': 'enthalpy',
                'size': 1
              },
              'props:tp2tot:S': {
                'val': 0.0,
                'relative_name': 'S',
                'shape': 1,
                'units': 'cal/(g*degK)',
                'desc': 'entropy',
                'size': 1
              },
              'props:tp2tot:gamma': {
                'relative_name': 'gamma',
                'shape': 1,
                'size': 1,
                'val': 0.0,
                'desc': 'ratio of specific heats'
              },
              'props:tp2tot:Cp': {
                'val': 0.0,
                'relative_name': 'Cp',
                'shape': 1,
                'units': 'cal/(g*degK)',
                'desc': 'Specific heat at constant pressure',
                'size': 1
              },
              'props:tp2tot:Cv': {
                'val': 0.0,
                'relative_name': 'Cv',
                'shape': 1,
                'units': 'cal/(g*degK)',
                'desc': 'Specific heat at constant volume',
                'size': 1
              },
              'props:tp2tot:rho': {
                'val': 0.0,
                'relative_name': 'rho',
                'shape': 1,
                'units': 'g/cm**3',
                'desc': 'density',
                'size': 1
              }
            }
          },
          'init_prod': {
            'init_prod:init_prod_amounts': {
              'shape': [3],
              'relative_name': 'init_prod_amounts',
              'val': [0.022722108611679163, 0.0, 0.0],
              'size': 3
            }
          },
          'temp': {
            'temp:T': {
              'units': 'degK',
              'shape': 1,
              'relative_name': 'T',
              'val': 4000.0,
              'size': 1
            }
          },
          'pressure': {
            'pressure:P': {
              'shape': 1,
              'relative_name': 'P',
              'val': 1.03421,
              'size': 1
            }
          },
          'stupid_english_units': {
            'stupid_english_units:T_eng': {
              'units': 'degR',
              'shape': 1,
              'relative_name': 'T_eng',
              'val': 0.0,
              'size': 1
            }
          }
        }
      };
    }(d3));
  </script>
</body>

</html>
